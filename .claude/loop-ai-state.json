{
  "notes": "第85轮（迭代9）：纯性能优化和代码质量修复，无新功能。\n\n1. 【代码质量】批量修复1169个材质文件中的双分号（import type from './types';;）：\n   - 第84轮批量替换脚本引入了双分号问题\n   - Python脚本一次性修复所有文件\n   - tsc验证通过，无功能影响\n\n2. 【性能优化】Crystal/Wire/Meteor/MoltenTitanium 改用DIRS4/DIRS8共享常量：\n   - Crystal.ts: const dirs: [number, number][] = [[0,-1]...] → [...DIRS4]（需要sort）\n   - Wire.ts: const dirs: [number, number][] → DIRS4（不需要sort）\n   - Meteor.ts: const dirs8: [number, number][] → DIRS8\n   - MoltenTitanium.ts: const explDirs: [number, number][] → DIRS8\n\n3. 【性能优化】新增DIRS3_SIDES常量，修复OilShale.ts：\n   - OilShale.ts 高温热解分支有 [[0,-1],[-1,0],[1,0]] 内联数组\n   - 在types.ts新增 DIRS3_SIDES 常量\n   - OilShale.ts 改用 DIRS3_SIDES\n\n4. 【性能优化】Rubber.ts 将update()内的临时new Set移到模块级别：\n   - 发现 Rubber.ts 在 update() 内部有 const SKIP = new Set([...]) 每帧分配\n   - 移到模块级别 const SKIP = new Set([...])\n\n5. 【性能优化】ThermomagneticMaterial/AcoustomagneticMaterial 同类修复：\n   - 两个文件在 update() 内部有 const metalIds = new Set([...]) 每帧分配\n   - 移到模块级别，重命名为 METAL_IDS\n\n6. 【性能优化】PhotothermalMaterial/Termite 消除每帧spread数组创建：\n   - 两个文件有 const allDirs = [...dirs, ...diag] 每帧创建新数组\n   - DIRS4 + DIRS_DIAG = DIRS8，直接改用 DIRS8 共享常量\n   - Termite.ts 的 sort 调用改为 [...allDirs].sort()\n\n7. 【已知剩余问题】8个文件仍有每帧spread副本（因为需要sort）：\n   - Coral/Mycelium/Mushroom/Foam/Clone/Portal/DielectricElastomer/Crystal\n   - 这些文件调用 [...DIRS4].sort() 或 [...DIRS8].sort()\n   - 可以用「随机起始索引+循环迭代」替代sort，彻底消除数组分配\n   - 但这是行为变化（随机排列→随机起始），需要谨慎评估\n\nbundle: 1434.43KB（与上轮基本持平，主要优化是GC压力减少）",
  "priorities": [
    "1. 【重要优化】将8个文件的 [...DIRS4].sort() 改为随机起始索引循环，彻底消除每帧数组分配：Coral/Mycelium/Mushroom/Foam/Clone/Portal/DielectricElastomer/Crystal",
    "2. 检查是否还有其他update()内的临时对象创建（new Map、new Array、对象字面量等）",
    "3. 检查绝对坐标neighbors数组（Dirt/Snow/Ice等26个文件）是否值得改为相对坐标+DIRS4模式",
    "4. 关注新材质批次（ID 1251+）的添加，确保使用DIRS4/DIRS8共享常量而非内联数组",
    "5. 检查Simulation.ts热路径是否还有可优化的地方（如避免重复计算idx）"
  ],
  "lessons": "1. tickAge()会干扰任何没有每帧调用setAge()的age用法。只有两种安全的age使用模式：\n   (a) 只读+自动递增：只调getAge，依赖tickAge递增（Clay/Lightning/Smoke等）\n   (b) 手动管理：每帧调setAge，阻止tickAge干扰（Fire/Wire/Clone等）\n2. set(x, y, id) 会重置 _age[i]=0。因此：\n   - 如果 if(age===0){setAge(init)} 后面立即有 set()+setAge()，init分支的 setAge 是冗余的\n   - 结论：任何在 set() 之前的 setAge 如果后面紧接着 set()+setAge，前者都是冗余的\n3. 全局 Map 状态（Ant.antStates, Portal.portalPairs）必须在所有 world.clear()/load()/restoreFromSnapshot() 调用时同步清理。\n4. 批量替换技巧：Python 正则脚本可以安全处理大量文件的模式替换，但需要：\n   (a) 同时更新 import 语句（区分 import type 和 import）\n   (b) 注意 ReadonlyArray 不能调用 sort()，需要 [...DIRS4].sort() 创建副本\n   (c) 替换后必须立即运行 tsc --noEmit 验证，不要等到最后\n   (d) 注意脚本可能引入双分号等副作用，需要额外检查\n5. 共享常量应标注 ReadonlyArray 类型，防止意外修改共享状态。如果需要修改，必须先 [...arr] 复制。\n6. update()内的临时对象创建（new Set/Map/Array）应移到模块级别。检查方法：\n   - 找到update函数体起始位置\n   - 在函数体内搜索 new Set/Map/Array\n   - 如果是固定内容（不依赖x/y参数），移到模块级别\n7. DIRS4 + DIRS_DIAG = DIRS8，可以直接用DIRS8替代 [...DIRS4, ...DIRS_DIAG] 的spread合并\n8. 随机方向遍历的两种方式：\n   (a) [...DIRS4].sort(() => Math.random() - 0.5) — 真随机排列，每帧分配数组\n   (b) 随机起始索引+循环 — 随机起始但相对顺序固定，无数组分配（更高效）\n   对于「找随机空位」的场景，(b)效果等价且更高效",
  "last_updated": "2026-02-28T10:00:00+08:00"
}
